<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
 <LINK REL="STYLESHEET" TYPE="text/css" HREF="../plsqldoc.css">
 <TITLE>Package pit</TITLE>
 <META name="object" content="PACKAGE">
 <META name="name" content="DOAG.pit">
 <META name="description" content="PIT-API package.">
</HEAD>
<BODY>
<TABLE WIDTH="100%"><TR>
<TD><P ALIGN="LEFT"><STRONG><SMALL>DOAG</SMALL></STRONG></TD>
<TD><P ALIGN="RIGHT"><STRONG><SMALL><A HREF="../index.html">index</A></SMALL></STRONG></TD>
</TR></TABLE>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="DESC_TEXT">
<P CLASS="MAIN_TITLE">Package pit</P>
PIT-API package. Implements all functionality that is required to utilize PIT in custom code.<br>

<BR>
</TD></TR></TABLE>
<HR>
<A NAME="Program units"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Program units
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_off">level_off</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_off
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_fatal">level_fatal</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_fatal
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_error">level_error</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_error
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_warn">level_warn</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_warn
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_info">level_info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_info
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_debug">level_debug</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_debug
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#level_all">level_all</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant level_all
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_off">trace_off</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant trace_off
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_mandatory">trace_mandatory</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant trace_mandatory
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_optional">trace_optional</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant trace_optional
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_detailed">trace_detailed</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant trace_detailed
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_all">trace_all</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Constant trace_all
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#verbose">verbose</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures <A HREF=#debug>debug</A> information, level verbose
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#debug">debug</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures debug information, level debug
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#info">info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures <A HREF=#debug>debug</A> information, level info
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#warn">warn</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures <A HREF=#debug>debug</A> information, level warn
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#error">error</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures <A HREF=#debug>debug</A> information, level error
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#fatal">fatal</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Captures <A HREF=#debug>debug</A> information, level fatal
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#sql_exception">sql_exception</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Exception handler that finally handles an <A HREF=#error>error</A> and calls <A HREF=#leave>leave</A>
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#stop">stop</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Exception handler that handles an <A HREF=#error>error</A> and calls <A HREF=#leave>leave</A> and re-raises the <A HREF=#error>error</A>
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_message_text">get_message_text</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Helper function to retrieve the text for a given message and msg_args-list
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#enter_mandatory">enter_mandatory</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces entering a method, level mandatory
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#enter_optional">enter_optional</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces entering a method, level optional
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#enter_detailed">enter_detailed</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces entering a method, level detailed
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#enter">enter</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces entering a method, level variable
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#leave_mandatory">leave_mandatory</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces leaving a method, level mandatory
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#leave_optional">leave_optional</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces leaving a method, level optional
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#leave_detailed">leave_detailed</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces leaving a method, level detailed
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#leave">leave</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Traces leaving a method, level variable
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#long_op">long_op</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to set dbms_application_info.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#print">print</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to pass a message to the view layer.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#purge_log">purge_log</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to purge the message log.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#purge_log2">purge_log</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to purge the message log.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#purge_session_log">purge_session_log</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to purge session related message log.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert">assert</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is true
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_is_null">assert_is_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_is_null2">assert_is_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_is_null3">assert_is_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_not_null">assert_not_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is not null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_not_null2">assert_not_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is not null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_not_null3">assert_not_null</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_condition is not null.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_exists">assert_exists</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_stmt returns any values
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert_not_exists">assert_not_exists</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Assertion function that checks whether p_stmt returns no values
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#set_context">set_context</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to set the trace context for the active session
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#reset_context">reset_context</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Procedure to reset the trace context for the active session to the default values
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_module_list">get_module_list</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Pipilined function to retrieve the list of available output modules
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#initialize">initialize</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Re-initializes the PIT
</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_off"></A>
<P CLASS="TYPE_TITLE">
level_off
</P>
<PRE CLASS="DECL_TEXT">
Function level_off return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_off<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level OFF<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_fatal"></A>
<P CLASS="TYPE_TITLE">
level_fatal
</P>
<PRE CLASS="DECL_TEXT">
Function level_fatal return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_fatal<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level <A HREF=#fatal>FATAL</A>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_error"></A>
<P CLASS="TYPE_TITLE">
level_error
</P>
<PRE CLASS="DECL_TEXT">
Function level_error return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_error<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level <A HREF=#error>ERROR</A>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_warn"></A>
<P CLASS="TYPE_TITLE">
level_warn
</P>
<PRE CLASS="DECL_TEXT">
Function level_warn return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_warn<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level <A HREF=#warn>WARN</A>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_info"></A>
<P CLASS="TYPE_TITLE">
level_info
</P>
<PRE CLASS="DECL_TEXT">
Function level_info return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_info<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level <A HREF=#info>INFO</A>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_debug"></A>
<P CLASS="TYPE_TITLE">
level_debug
</P>
<PRE CLASS="DECL_TEXT">
Function level_debug return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_debug<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level <A HREF=#debug>DEBUG</A>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="level_all"></A>
<P CLASS="TYPE_TITLE">
level_all
</P>
<PRE CLASS="DECL_TEXT">
Function level_all return number

</PRE>
<P CLASS="DESC_TEXT">
Constant level_all<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for <A HREF=#debug>debug</A> level ALL<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_off"></A>
<P CLASS="TYPE_TITLE">
trace_off
</P>
<PRE CLASS="DECL_TEXT">
Function trace_off return number

</PRE>
<P CLASS="DESC_TEXT">
Constant trace_off<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for trace level OFF<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_mandatory"></A>
<P CLASS="TYPE_TITLE">
trace_mandatory
</P>
<PRE CLASS="DECL_TEXT">
Function trace_mandatory return number

</PRE>
<P CLASS="DESC_TEXT">
Constant trace_mandatory<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for trace level MANDATORY<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_optional"></A>
<P CLASS="TYPE_TITLE">
trace_optional
</P>
<PRE CLASS="DECL_TEXT">
Function trace_optional return number

</PRE>
<P CLASS="DESC_TEXT">
Constant trace_optional<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for trace level OPTIONAL<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_detailed"></A>
<P CLASS="TYPE_TITLE">
trace_detailed
</P>
<PRE CLASS="DECL_TEXT">
Function trace_detailed return number

</PRE>
<P CLASS="DESC_TEXT">
Constant trace_detailed<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for trace level DETAILED<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_all"></A>
<P CLASS="TYPE_TITLE">
trace_all
</P>
<PRE CLASS="DECL_TEXT">
Function trace_all return number

</PRE>
<P CLASS="DESC_TEXT">
Constant trace_all<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Getter function for trace level ALL<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="verbose"></A>
<P CLASS="TYPE_TITLE">
verbose
</P>
<PRE CLASS="DECL_TEXT">
Procedure verbose(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures <A HREF=#debug>debug</A> information, level verbose<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit <A HREF=#debug>debug</A> messages. Normal usage is to report verbose information that is useful for a detailled code insight on development and production systems.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="debug"></A>
<P CLASS="TYPE_TITLE">
debug
</P>
<PRE CLASS="DECL_TEXT">
Procedure debug(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures debug information, level debug<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit debug messages. Normal usage is to report additional information that is useful in tracing a bug on development and production systems.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="info"></A>
<P CLASS="TYPE_TITLE">
info
</P>
<PRE CLASS="DECL_TEXT">
Procedure info(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures <A HREF=#debug>debug</A> information, level info<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit info messages. Normal usage is to report information that is useful in normal operation on development and production systems. In contrast to <A HREF=#warn>Warn</A>, <A HREF=#error>ERROR</A> and <A HREF=#fatal>FATAL</A>, this information will be reported more frequently on production systems.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="warn"></A>
<P CLASS="TYPE_TITLE">
warn
</P>
<PRE CLASS="DECL_TEXT">
Procedure warn(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures <A HREF=#debug>debug</A> information, level warn<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit warning messages. Normal usage is to report uncommon behavior of the system which is not categorized as <A HREF=#error>error</A>, such as warning thresholds reached etc.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="error"></A>
<P CLASS="TYPE_TITLE">
error
</P>
<PRE CLASS="DECL_TEXT">
Procedure error(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures <A HREF=#debug>debug</A> information, level error<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit error messages. Normal usage is to report errors which have occured but which are not seen as <A HREF=#fatal>fatal</A> for the application.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="fatal"></A>
<P CLASS="TYPE_TITLE">
fatal
</P>
<PRE CLASS="DECL_TEXT">
Procedure fatal(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Captures <A HREF=#debug>debug</A> information, level fatal<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit fatal <A HREF=#error>error</A> messages. Normal usage is to report errors which cause the application to abort operation.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="sql_exception"></A>
<P CLASS="TYPE_TITLE">
sql_exception
</P>
<PRE CLASS="DECL_TEXT">
Procedure sql_exception(p_message_name in varchar2,
                        p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Exception handler that finally handles an <A HREF=#error>error</A> and calls <A HREF=#leave>leave</A>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure in EXCEPTION handlers of your code.<br> <code>sql_exception</code> not only reports the <A HREF=#error>error</A> but handles it as well. This means that if you pass any <A HREF=#error>error</A> that occurred to this procedure, the <A HREF=#error>error</A> gets logged and handled.<br> <code>sql_exception</code> includes a call to <code>leave</code>, so there is no need to call <code>leave</code> explicitly.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="stop"></A>
<P CLASS="TYPE_TITLE">
stop
</P>
<PRE CLASS="DECL_TEXT">
Procedure stop(p_message_name in varchar2, p_arg_list msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Exception handler that handles an <A HREF=#error>error</A> and calls <A HREF=#leave>leave</A> and re-raises the <A HREF=#error>error</A>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure in EXCEPTION handlers of your code.<br> <code>stop</code> not only reports the <A HREF=#error>error</A> but handles it as well. This means that if you pass any <A HREF=#error>error</A> that occurred to this procedure, the <A HREF=#error>error</A> gets logged and handled.<br> <code>stop</code> includes a call to <code>leave</code>, so there is no need to call <code>leave</code> explicitly.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_message_text"></A>
<P CLASS="TYPE_TITLE">
get_message_text
</P>
<PRE CLASS="DECL_TEXT">
Function get_message_text(p_message_name in varchar2,
                          p_arg_list     in msg_args default null)
  return clob

</PRE>
<P CLASS="DESC_TEXT">
Helper function to retrieve the text for a given message and msg_args-list<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this function to get a translated message with replaced arguments for your usage within the code you write.<br> This function is a convenience function for you if you need to compose more complex content for the application that includes translated messages.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Returns"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Returns
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
clob<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="enter_mandatory"></A>
<P CLASS="TYPE_TITLE">
enter_mandatory
</P>
<PRE CLASS="DECL_TEXT">
Procedure enter_mandatory(p_action in varchar2 default null,
                          p_module in varchar2 default null,
                          p_params in msg_params default null)

</PRE>
<P CLASS="DESC_TEXT">
Traces entering a method, level mandatory<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to indicate the entrance to a method that always should be traced (should tracing be switched on).<br> Normal usage is to call this procedure within the major procedures for a given use case.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the method is used for. You may choose the method name or a free description.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the environment of that method is. If null, it defaults <ul> <li>to the module of the predecessor at the call stack, if existing</li> <li>to the package name</li> </ul>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_params&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Instance of <code>msg_params</code> with a list of key-value pairs representing parameter name and -value.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="enter_optional"></A>
<P CLASS="TYPE_TITLE">
enter_optional
</P>
<PRE CLASS="DECL_TEXT">
Procedure enter_optional(p_action in varchar2 default null,
                         p_module in varchar2 default null,
                         p_params in msg_params default null)

</PRE>
<P CLASS="DESC_TEXT">
Traces entering a method, level optional<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to indicate the entrance to a method that optionally should be traced (should tracing be switched on).<br> Normal usage is to call this procedure within detail procedures for a given use case.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the method is used for. You may choose the method name or a free description.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the environment of that method is. If null, it defaults <ul> <li>to the module of the predecessor at the call stack, if existing</li> <li>to the package name</li> </ul>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_params&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Instance of <code>msg_params</code> with a list of key-value pairs representing parameter name and -value.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="enter_detailed"></A>
<P CLASS="TYPE_TITLE">
enter_detailed
</P>
<PRE CLASS="DECL_TEXT">
Procedure enter_detailed(p_action in varchar2 default null,
                         p_module in varchar2 default null,
                         p_params in msg_params default null)

</PRE>
<P CLASS="DESC_TEXT">
Traces entering a method, level detailed<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to indicate the entrance to a method that should be traced on development only (should tracing be switched on).<br> Normal usage is to call this procedure within the helper procedures to allow for detailled performance analysis.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the method is used for. You may choose the method name or a free description.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the environment of that method is. If null, it defaults <ul> <li>to the module of the predecessor at the call stack, if existing</li> <li>to the package name</li> </ul>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_params&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Instance of <code>msg_params</code> with a list of key-value pairs representing parameter name and -value.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="enter"></A>
<P CLASS="TYPE_TITLE">
enter
</P>
<PRE CLASS="DECL_TEXT">
Procedure enter(p_action      in varchar2 default null,
                p_module      in varchar2 default null,
                p_params      in msg_params default null,
                p_trace_level in number default <A HREF=#trace_all>pit.trace_all</A>)

</PRE>
<P CLASS="DESC_TEXT">
Traces entering a method, level variable<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure if you don't want to distinguish between trace levels or if you want to pass a trace level as a parameter from the environmental procedures.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the method is used for. You may choose the method name or a free description.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the environment of that method is. If null, it defaults <ul> <li>to the module of the predecessor at the call stack, if existing</li> <li>to the package name</li> </ul>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_params&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Instance of <code>msg_params</code> with a list of key-value pairs representing parameter name and -value.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="leave_mandatory"></A>
<P CLASS="TYPE_TITLE">
leave_mandatory
</P>
<PRE CLASS="DECL_TEXT">
Procedure leave_mandatory

</PRE>
<P CLASS="DESC_TEXT">
Traces leaving a method, level mandatory<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure if you normally <A HREF=#leave>leave</A> a method. It's important to make sure that any possible exit point of a method first calls this procedure to make sure that the call stack is correctly maintained.<br> Also, make sure that the stack level corresponds to the respective <code>enter_...</code> procedure to avoid call stack confusion if the trace level is set to a lower level.<br> Specify optional parameter <code>p_action</code> if you want to assure that the call stack is maintained correctly, as <code>PIT</code> will throw an <A HREF=#error>error</A> if this parameter does not match the respective action entry on the call stack.<br> No call to this procedure is required in <code>exception</code>-Blocks if you called <code>sql_exception</code> or <code>stop</code> within the exception block, as these procedures handle this call.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Short description of what the method is used for. If used, assertain that you choose the exact name as for the corresponding enter-method.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="leave_optional"></A>
<P CLASS="TYPE_TITLE">
leave_optional
</P>
<PRE CLASS="DECL_TEXT">
Procedure leave_optional

</PRE>
<P CLASS="DESC_TEXT">
Traces leaving a method, level optional<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure if you normally <A HREF=#leave>leave</A> a method. It's important to make sure that any possible exit point of a method first calls this procedure to make sure that the call stack is correctly maintained.<br> Also, make sure that the stack level corresponds to the respective <code>enter_...</code> procedure to avoid call stack confusion if the trace level is set to a lower level.<br> Specify optional parameter <code>p_action</code> if you want to assure that the call stack is maintained correctly, as <code>PIT</code> will throw an <A HREF=#error>error</A> if this parameter does not match the respective action entry on the call stack.<br> No call to this procedure is required in <code>exception</code>-Blocks if you called <code>sql_exception</code> or <code>stop</code> within the exception block, as these procedures handle this call.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="leave_detailed"></A>
<P CLASS="TYPE_TITLE">
leave_detailed
</P>
<PRE CLASS="DECL_TEXT">
Procedure leave_detailed

</PRE>
<P CLASS="DESC_TEXT">
Traces leaving a method, level detailed<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure if you normally <A HREF=#leave>leave</A> a method. It's important to make sure that any possible exit point of a method first calls this procedure to make sure that the call stack is correctly maintained.<br> Also, make sure that the stack level corresponds to the respective <code>enter_...</code> procedure to avoid call stack confusion if the trace level is set to a lower level.<br> Specify optional parameter <code>p_action</code> if you want to assure that the call stack is maintained correctly, as <code>PIT</code> will throw an <A HREF=#error>error</A> if this parameter does not match the respective action entry on the call stack.<br> No call to this procedure is required in <code>exception</code>-Blocks if you called <code>sql_exception</code> or <code>stop</code> within the exception block, as these procedures handle this call.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="leave"></A>
<P CLASS="TYPE_TITLE">
leave
</P>
<PRE CLASS="DECL_TEXT">
Procedure leave(p_trace_level in number default <A HREF=#trace_all>pit.trace_all</A>)

</PRE>
<P CLASS="DESC_TEXT">
Traces leaving a method, level variable<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure if you normally leave a method. It's important to make sure that any possible exit point of a method first calls this procedure to make sure that the call stack is correctly maintained.<br> Specify optional parameter <code>p_action</code> if you want to assure that the call stack is maintained correctly, as <code>PIT</code> will throw an <A HREF=#error>error</A> if this parameter does not match the respective action entry on the call stack.<br> No call to this procedure is required in <code>exception</code>-Blocks if you called <code>sql_exception</code> or <code>stop</code> within the exception block, as these procedures handle this call.<br> Call this procedure if you don't want to distinguish between trace levels or if you want to pass a trace level as a parameter from the environmental procedures.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_trace_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional trace level. References <code>trace_level</code><br> defaults to <code>trace_all</code>.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="long_op"></A>
<P CLASS="TYPE_TITLE">
long_op
</P>
<PRE CLASS="DECL_TEXT">
Procedure long_op(p_operation in varchar2,
                  p_sofar     in number,
                  p_total     in number default 100)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to set dbms_application_info.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Use this procedure to pass information about long operations to the database. If this task is completed, call this procedure with <code>p_sofar = p_total</code> to allow for proper state cleansing.<br> If you call <code>sql_exception</code> or <code>stop</code>, the state will be cleaned as well.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_operation&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Description of the operation<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_sofar&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Percentage of the task completed (0 .. 100 or individual scale)<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_total&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Amount of work to be done. Defaults to 100 (percent)<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="print"></A>
<P CLASS="TYPE_TITLE">
print
</P>
<PRE CLASS="DECL_TEXT">
Procedure print(p_message_name in varchar2,
                p_arg_list     in msg_args default null)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to pass a message to the view layer.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to emit a message to the output modules.<br> Normal usage is to call the procedure if you want to display translated messages on the applications GUI. Therefore, this procedure needs to be implemented by the output module for your application environment.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="purge_log"></A>
<P CLASS="TYPE_TITLE">
purge_log
</P>
<PRE CLASS="DECL_TEXT">
Procedure purge_log(p_date_before in date)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to purge the message log. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to clean up logging information. Only useful if your output modules support purging of log information, such as <code>PIT_TABLE</code> output module.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_date_until&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Date to indicate up to when the log should be purged.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="purge_log2"></A>
<P CLASS="TYPE_TITLE">
purge_log
</P>
<PRE CLASS="DECL_TEXT">
Procedure purge_log(p_days_before in number)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to purge the message log. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to clean up logging information. Only useful if your output modules support purging of log information, such as <code>PIT_TABLE</code> output module.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_days_since&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Number of days the logging should be kept.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="purge_session_log"></A>
<P CLASS="TYPE_TITLE">
purge_session_log
</P>
<PRE CLASS="DECL_TEXT">
Procedure purge_session_log(p_session_id in varchar2 default null)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to purge session related message log.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to clean up logging information. Only useful if your output modules support purging of log information, such as <code>PIT_TABLE</code> output module.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_session_id&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional session_id. If null, the active session is purged.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert"></A>
<P CLASS="TYPE_TITLE">
assert
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert(p_condition    in boolean,
                 p_message_name in varchar2 default msg.ASSERT_TRUE,
                 p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is true<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_TRUE</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Boolean expression to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_is_null"></A>
<P CLASS="TYPE_TITLE">
assert_is_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_is_null(p_condition    in varchar2,
                         p_message_name in varchar2 default msg.ASSERT_IS_NULL,
                         p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_IS_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
entity to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_is_null2"></A>
<P CLASS="TYPE_TITLE">
assert_is_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_is_null(p_condition    in number,
                         p_message_name in varchar2 default msg.ASSERT_IS_NULL,
                         p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_IS_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
entity to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_is_null3"></A>
<P CLASS="TYPE_TITLE">
assert_is_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_is_null(p_condition    in date,
                         p_message_name in varchar2 default msg.ASSERT_IS_NULL,
                         p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_IS_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
entity to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_not_null"></A>
<P CLASS="TYPE_TITLE">
assert_not_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_not_null(p_condition    in varchar2,
                          p_message_name in varchar2 default msg.ASSERT_IS_NOT_NULL,
                          p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is not null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_NOT_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Boolean expression to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_not_null2"></A>
<P CLASS="TYPE_TITLE">
assert_not_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_not_null(p_condition    in number,
                          p_message_name in varchar2 default msg.ASSERT_IS_NOT_NULL,
                          p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is not null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_NOT_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Boolean expression to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_not_null3"></A>
<P CLASS="TYPE_TITLE">
assert_not_null
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_not_null(p_condition    in date,
                          p_message_name in varchar2 default msg.ASSERT_IS_NOT_NULL,
                          p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_condition is not null. Overloaded<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Methods for &lt;em&gt;Contract Driven Development&lt;/em&gt;<br> Use this procedure to check whether an expression evaluates to true. If the assertion fails, an <A HREF=#error>error</A> is thrown.<br> You may choose to throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_NOT_NULL</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_condition&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Boolean expression to check.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_exists"></A>
<P CLASS="TYPE_TITLE">
assert_exists
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_exists(p_stmt         in varchar2,
                        p_message_name in varchar2 default msg.ASSERT_EXISTS,
                        p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_stmt returns any values<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Pass a select statement that is expected to return a row. If the statement does return a row, it will silently quit, otherwise it will throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_EXISTS</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_stmt&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
SQL-statement that either returns rows or not.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="assert_not_exists"></A>
<P CLASS="TYPE_TITLE">
assert_not_exists
</P>
<PRE CLASS="DECL_TEXT">
Procedure assert_not_exists(p_stmt         in varchar2,
                            p_message_name in varchar2 default msg.ASSERT_NOT_EXISTS,
                            p_arg_list     msg_args := null)

</PRE>
<P CLASS="DESC_TEXT">
Assertion function that checks whether p_stmt returns no values<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Pass a select statement that is expected to return no rows. If the statement does not return a row, it will silently quit, otherwise it will throw a client specific <A HREF=#error>error</A> message. If this parameter is not set, a default message <code>msg.ASSERT_NOT_EXISTS</code> is used.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_stmt&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
SQL-statement that either returns rows or not.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_message_name&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the message. Reference to package MSG<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_arg_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional list of replacement information<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="set_context"></A>
<P CLASS="TYPE_TITLE">
set_context
</P>
<PRE CLASS="DECL_TEXT">
Procedure set_context(p_log_level    in integer,
                      p_trace_level  in integer,
                      p_trace_timing in boolean,
                      p_module_list  in varchar2)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to set the trace context for the active session<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to dynamically change the <A HREF=#debug>debug</A> settings to allow for dynamic debugging from within an application.<br> Normal usage is to specify that the active session only should be logged and/or traced. Set the options you wish and immediately these settings apply. To reset logging to the default call <code>reset_context</code>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_log_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Requested log level<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_trace_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Requested stack level<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_timing_on&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Flag to indicate whehter timing information should be captured.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_module_list&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Colon-separated list of output modules to be used.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_active_session_only&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Flag to indicate whether the active session should be traced only. This works in connection pool environments as well but expects to be able to distinguish a session from others if used in this context.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="reset_context"></A>
<P CLASS="TYPE_TITLE">
reset_context
</P>
<PRE CLASS="DECL_TEXT">
Procedure reset_context(p_active_session_only in boolean default true)

</PRE>
<P CLASS="DESC_TEXT">
Procedure to reset the trace context for the active session to the default values<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this procedure to reset trace/debug setting to the default.<br> If <code>p_active_session_only</code> is true, other settings remain unchanged. If false, any context is immediately set back to default. This option is useful to clean up any unwanted debugging.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
p_active_session_only&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Flag to indicate whether the active session should be reset only.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_module_list"></A>
<P CLASS="TYPE_TITLE">
get_module_list
</P>
<PRE CLASS="DECL_TEXT">
Function get_module_list return args

</PRE>
<P CLASS="DESC_TEXT">
Pipilined function to retrieve the list of available output modules<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Helper function to get a list of available ourput modules.<br> Useful to populate a drop down list of output modules.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="initialize"></A>
<P CLASS="TYPE_TITLE">
initialize
</P>
<PRE CLASS="DECL_TEXT">
Procedure initialize

</PRE>
<P CLASS="DESC_TEXT">
Re-initializes the PIT<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Initializes the package. Either called implicitly upon first instantiation or explicitly upon request.<br>

</TD></TR>
</TABLE>
<BR>
<P>&nbsp;</P>
<P>&nbsp;</P>
</BODY>
</HTML>
